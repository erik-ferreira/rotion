## Comunicação IPC(Inter-process communication)

- Preload é um script que acessa apis especificas do processo server side, mas roda no client side
- Principais tipos de IPC:
  1. Renderer to main(one-way)
  2. Renderer to main(two-way)
  3. Main to renderer

### Iniciando integração

- src > main > ipc.ts

  ```ts
  import { ipcMain } from "electron";

  // Método on para receber uma comunicação(1)
  ipcMain.on("fetch-document", (event, params) => {
    console.log("params", params);
  });

  // Método handle para receber e enviar uma comunicação(2)
  // Precisa ser async
  ipcMain.handle("get-list", async (event, params) => {
    return "list";
  });
  ```

- src > preload > index.ts:

  ```ts
  import { contextBridge, ipcRenderer } from "electron";
  import { electronAPI, ElectronAPI } from "@electron-toolkit/preload";

  declare global {
    export interface Window {
      electron: ElectronAPI;
      api: typeof api; // Para pegar a tipagem do objeto api abaixo
    }
  }

  const api = {
    // Apenas para enviar a comunicação(1)
    fetchDocument(params: any) {
      return ipcRenderer.send("fetch-document", params);
    },

    // Método invoke para receber e enviar uma comunicação(2)
    getList() {
      return ipcRenderer.invoke("get-list");
    },
  };

  /*
    Esse contextIsolated garante que as apis do server-side vão ser acessadas no seu contexto correto; Antes disso
    elas era acessadas em qualquer lugar da aplicação
  */
  if (process.contextIsolated) {
    try {
      /*
      contextBridge = Ponte entre o renderer e o main
      exposeInMainWorld = Para expor uma funcionalidade para o rerender
      */
      contextBridge.exposeInMainWorld("electron", electronAPI);
      contextBridge.exposeInMainWorld("api", api);
    } catch (error) {
      console.error(error);
    }
  } else {
    // @ts-ignore (define in dts)
    window.electron = electronAPI;
    // @ts-ignore (define in dts)
    window.api = api;
  }
  ```

- src > renderer > componente de Sidebar:

  ```ts
  // Apenas para enviar a comunicação(1)
  window.api.fetchDocument("I Love Basketball");

  // Método para receber e enviar uma comunicação(2)
  // Será uma promise
  window.api.getList().then(console.log);
  ```

## Configurando React Query

- `npm i @tanstack/react-query`
- src > lib > react-query.ts:

  ```ts
  import { QueryClient } from "@tanstack/react-query";

  export const queryClient = new QueryClient();
  ```

- src > App.tsx:

  ```tsx
  export function App() {
    return (
      <QueryClientProvider client={queryClient}>
        <Routes />
      </QueryClientProvider>
    );
  }
  ```

- src > components > Sidebar.tsx:

  ```tsx
  export function Sidebar() {
    const { data } = useQuery(
      ["document"],
      async () => {
        const response = await window.api.fetchDocument();

        return response;
      },
      {}
    );
  }

  /*
    - Além do data na desestruturação, o react query devolve vários estados como isLoading, isError, isFetching e etc
    - O primeiro parâmetro do useQuery é uma query key, ou seja, um id único para essa query
    - refetchOnFocus: toda chamada api que estiver em tela visível para o usuário, quando o usuário voltar para a 
      aplicação, essa chamada será refeita do zero; No objeto vazio(121), pode se configurar melhor essa funcionalidade,
      como intervalo em que ela vai ser executada, se a fetch sera refeita quando a internet voltar e etc.
  */
  ```
